"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compile;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _kleur = _interopRequireDefault(require("kleur"));

var babel = _interopRequireWildcard(require("@babel/core"));

var _browserslist = _interopRequireDefault(require("browserslist"));

var _glob = _interopRequireDefault(require("glob"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function compile({
  root,
  source,
  output,
  babelrc = false,
  configFile = false,
  modules,
  copyFlow,
  sourceMaps = true,
  report
}) {
  const files = _glob.default.sync('**/*', {
    cwd: source,
    absolute: true,
    nodir: true,
    ignore: '**/{__tests__,__fixtures__,__mocks__}/**'
  });

  report.info(`Compiling ${_kleur.default.blue(String(files.length))} files in ${_kleur.default.blue(_path.default.relative(root, source))} with ${_kleur.default.blue('babel')}`);
  await Promise.all(files.map(async filepath => {
    const outputFilename = _path.default.join(output, _path.default.relative(source, filepath)).replace(/\.(jsx?|tsx?)$/, '.js');

    await _fsExtra.default.mkdirp(_path.default.dirname(outputFilename));

    if (!/\.(jsx?|tsx?)$/.test(filepath)) {
      // Copy files which aren't source code
      _fsExtra.default.copy(filepath, outputFilename);

      return;
    }

    const content = await _fsExtra.default.readFile(filepath, 'utf-8');
    const result = await babel.transformAsync(content, {
      cwd: root,
      babelrc: babelrc,
      configFile: configFile,
      sourceMaps,
      sourceRoot: _path.default.relative(_path.default.dirname(outputFilename), source),
      sourceFileName: _path.default.relative(source, filepath),
      filename: filepath,
      ...(babelrc || configFile ? null : {
        presets: [[require.resolve('@babel/preset-env'), {
          targets: _browserslist.default.findConfig(root) ?? {
            browsers: ['>1%', 'last 2 chrome versions', 'last 2 edge versions', 'last 2 firefox versions', 'last 2 safari versions', 'not dead', 'not ie <= 11', 'not op_mini all', 'not android <= 4.4', 'not samsung <= 4'],
            node: '16'
          },
          useBuiltIns: false,
          modules
        }], require.resolve('@babel/preset-react'), require.resolve('@babel/preset-typescript'), require.resolve('@babel/preset-flow')]
      })
    });

    if (result == null) {
      throw new Error('Output code was null');
    }

    let code = result.code;

    if (sourceMaps && result.map) {
      const mapFilename = outputFilename + '.map';
      code += '\n//# sourceMappingURL=' + _path.default.basename(mapFilename); // Don't inline the source code, it can be retrieved from the source file

      result.map.sourcesContent = undefined;

      _fsExtra.default.writeFileSync(mapFilename, JSON.stringify(result.map));
    }

    await _fsExtra.default.writeFile(outputFilename, code);

    if (copyFlow) {
      _fsExtra.default.copy(filepath, outputFilename + '.flow');
    }
  }));
  report.success(`Wrote files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
}
//# sourceMappingURL=compile.js.map