"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;

var _kleur = _interopRequireDefault(require("kleur"));

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _which = _interopRequireDefault(require("which"));

var _crossSpawn = _interopRequireDefault(require("cross-spawn"));

var _del = _interopRequireDefault(require("del"));

var _json = _interopRequireDefault(require("json5"));

var _os = require("os");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function build({
  root,
  output,
  report,
  options
}) {
  report.info(`Cleaning up previous build at ${_kleur.default.blue(_path.default.relative(root, output))}`);
  await (0, _del.default)([output]);
  report.info(`Generating type definitions with ${_kleur.default.blue('tsc')}`);
  const project = options !== null && options !== void 0 && options.project ? options.project : 'tsconfig.json';

  const tsconfig = _path.default.join(root, project);

  try {
    if (await _fsExtra.default.pathExists(tsconfig)) {
      try {
        const config = _json.default.parse(await _fsExtra.default.readFile(tsconfig, 'utf-8'));

        if (config.compilerOptions) {
          const conflicts = [];

          if (config.compilerOptions.noEmit !== undefined) {
            conflicts.push('compilerOptions.noEmit');
          }

          if (config.compilerOptions.emitDeclarationOnly !== undefined) {
            conflicts.push('compilerOptions.emitDeclarationOnly');
          }

          if (config.compilerOptions.declarationDir) {
            conflicts.push('compilerOptions.declarationDir');
          }

          if (config.compilerOptions.outDir && _path.default.join(root, config.compilerOptions.outDir) !== output) {
            conflicts.push('compilerOptions.outDir');
          }

          if (conflicts.length) {
            report.warn(`Found following options in the config file which can conflict with the CLI options. Please remove them from ${_kleur.default.blue(project)}:${conflicts.reduce((acc, curr) => acc + `\n${_kleur.default.gray('-')} ${_kleur.default.yellow(curr)}`, '')}`);
          }
        }
      } catch (e) {
        report.warn(`Couldn't parse '${project}'. There might be validation errors.`);
      }
    } else {
      throw new Error(`Couldn't find a ${_kleur.default.blue('tsconfig.json')} in the project root.`);
    }

    let tsc;

    if (options !== null && options !== void 0 && options.tsc) {
      tsc = _path.default.resolve(root, options.tsc);

      if (!(await _fsExtra.default.pathExists(tsc))) {
        throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed at ${_kleur.default.blue(tsc)}. Please specify the correct path in options or remove it to use the workspace's version.`);
      }
    } else {
      var _execpath$split$pop;

      const execpath = process.env.npm_execpath;
      const cli = execpath !== null && execpath !== void 0 && (_execpath$split$pop = execpath.split('/').pop()) !== null && _execpath$split$pop !== void 0 && _execpath$split$pop.includes('yarn') ? 'yarn' : 'npm';

      try {
        if (cli === 'yarn') {
          const result = _crossSpawn.default.sync('yarn', ['bin', 'tsc'], {
            stdio: 'pipe',
            encoding: 'utf-8',
            cwd: root
          });

          tsc = result.stdout.trim();
        } else {
          const result = _crossSpawn.default.sync('npm', ['bin'], {
            stdio: 'pipe',
            encoding: 'utf-8',
            cwd: root
          });

          tsc = _path.default.resolve(result.stdout.trim(), 'tsc');
        }
      } catch (e) {
        tsc = _path.default.resolve(root, 'node_modules', '.bin', 'tsc');
      }

      if ((0, _os.platform)() === 'win32' && !tsc.endsWith('.cmd')) {
        tsc += '.cmd';
      }
    }

    if (!(await _fsExtra.default.pathExists(tsc))) {
      try {
        tsc = await (0, _which.default)('tsc');

        if (await _fsExtra.default.pathExists(tsc)) {
          report.warn(`Failed to locate 'tsc' in the workspace. Falling back to the globally installed version. Consider adding ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specifying the ${_kleur.default.blue('tsc')} option for the typescript target.`);
        }
      } catch (e) {// Ignore
      }
    }

    if (tsc == null || !(await _fsExtra.default.pathExists(tsc))) {
      throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed under ${_kleur.default.blue('node_modules')} or present in $PATH. Make sure you have added ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specify the ${_kleur.default.blue('tsc')} option for typescript.`);
    }

    const tsbuildinfo = _path.default.join(output, project.replace(/\.json$/, '.tsbuildinfo'));

    try {
      await (0, _del.default)([tsbuildinfo]);
    } catch (e) {// Ignore
    }

    const result = _crossSpawn.default.sync(tsc, ['--pretty', '--declaration', '--declarationMap', '--emitDeclarationOnly', '--project', project, '--outDir', output], {
      stdio: 'inherit',
      cwd: root
    });

    if (result.status === 0) {
      await (0, _del.default)([tsbuildinfo]);
      report.success(`Wrote definition files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
    } else {
      throw new Error('Failed to build definition files.');
    }
  } catch (e) {
    if (e.stdout) {
      report.error(`Errors found when building definition files:\n${e.stdout.toString()}`);
    } else {
      report.error(e.message);
    }

    throw new Error('Failed to build definition files.');
  }
}
//# sourceMappingURL=typescript.js.map